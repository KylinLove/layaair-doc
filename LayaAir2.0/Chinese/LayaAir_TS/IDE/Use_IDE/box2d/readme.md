## 学会用Box2D可视化编辑物理游戏【LayaAir 2.0教学】

> author: Charley    Date: 2020-12-1

很多开发者都知道LayaAir引擎的3D功能成熟与强大，其实对于LayaAir的2D与IDE认识并不多，或者说是停留在LayaAir 1.0的时代里。本篇文档，旨在让开发者进一步了解LayaAirIDE的重要功能之一，物理游戏的可视化编辑与开发。这也是LayaAirIDE 2.0的重要新特性之一，希望大家能通过本文更全面的了解LayaAir引擎与IDE，快速开发物理小游戏。

### 一、基础知识

#### 1.1  学习本文需要的前置知识

##### LayaAir引擎相关

要顺畅完整的学习本篇文档，首先必须要了解LayaAirIDE的基础，比如UI组件的熟练使用。

视频课链接： https://ke.qq.com/course/275321 

也要对LayaAirIDE组件化开发相关比较熟悉。

视频课链接： https://ke.qq.com/course/427324

如果对这两块都不熟悉的，可以查看这两种课的视频合集：

 视频课链接：https://ke.qq.com/course/417469 

##### 物理学基础概念相关

本篇不可避免的会涉及一些物理学相关的基础概念，文中会尽可能简要说明，让大家理解作用与效果。但如果大家对于某块基础概念不理解，或者想进一步深入理解，需自行补习相关的基础知识。本篇重点在于介绍引擎中相关属性的作用与如何使用。

#### 1.2 LayaAir内置的物理引擎

LayaAir引擎在1.x的时候内置的是Matter.js物理引擎，核心原因是小巧轻便。但随着微信小游戏产业的兴起，以及物理小游戏的火爆，带动一阵物理小游戏的热潮，因此，对于物理游戏的需求也越来越多。从精度、圆形支持、防穿透等方面，Matter.js已经不能满足。于是在LayaAir 2.0引擎开始，选择了更加成熟和应用最广泛的Box2D作为LayaAir引擎内置的2D物理引擎，并且整合到LayaAirIDE中，可以通过LayaAirIDE可视化编辑物理游戏。让物理游戏开发起来更加轻松。

>  如果对于物理引擎功能需求较为简单，并且希望能减小引擎体积的情况下，LayaAir引擎仍然可以结合使用Matter物理引擎。 但不在本篇范围内，本篇以集成的Box2D物理引擎为基础，旨在介绍如何在LayaAirIDE中使用物理引擎组件。

### 二、物理引擎基础

完整的Box2D物理引擎要讲的内容比较多，本篇文档仅基于LayaAirIDE中的物理组件使用进行相关介绍，满足开发者理解物理组件，进行可视化开发物理游戏即可。下面我们重点来介绍一下 刚体、碰撞体、关节。

#### 2.1  **刚体 `RigidBody`** 

Box2D可以说是一个用于游戏的2D刚体仿真库。所以，刚体是我们需要首先理解的概念，是本小节中，我们围绕刚体进行介绍。

##### 2.1.1 刚体的定义

大家都知道，自然界一切有形体的物质，都可以叫物体。刚体是力学中为了体现物体特性的一种科学抽象概念，也是一种理想状态的力学表达模型，**是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。** 

然而，现实中不可能存在这种理想模型，物体在受力之后，会根据力、材料、弹性、 塑性等综合因素，决定是否改变或改变多少。 如果物体本身的变化不影响整个运动过程，为使被研究的问题简化，仍将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 

##### 2.1.2 刚体组件属性说明

LayaAir引擎中的2D刚体组件类是 `laya.physics.RigidBody` ，继承自创建组件的基类 Component。在LayaAirIDE中，我们可以直接为UI组件添加刚体组件。如下图1所示。

![图1](img/1.png) 

(图1)

##### 刚体类型 `type`

刚体支持三种类型(type)：静态类型`static`、动态类型`dynamic`、运动学类型`kinematic`，默认为`dynamic`。 如图2-1所示。

![图2-1](img/2-1.png) 

(图2-1)

###### 静态类型：`static`

static类型的刚体就是**始终静止不动**，无论施加怎样的力都不会移动， **不会受到重力影响**，**速度为零， 质量为零 **。 可以通过代码对节点的移动，旋转，缩放，对其进行控制。

> 在LayaAirIDE中创建的2D示例项目中，永远不会移动的地板，就是使用的static类型刚体。

###### 动态类型：`dynamic` 

dynamic类型的刚体**会根据受到的力进行移动**，也可以被用户手动移动， **会受到重力的影响，可设置速度，质量必须非零。**

> 在LayaAirIDE中创建的2D示例项目中，受重力影响而不断掉落的方块盒子，使用的就是dynamic类型刚体。

###### 运动学类型：`kinematic`

kinematic类型的刚体**不受重力影响，可设置速度，质量为零。**可以被用户手动移动，但通常会通过设置速度使其移动。

> 在LayaAirIDE中创建的2D示例项目中，向上撞击或击碎方块盒子的圆形子弹，使用的就是kinematic类型刚体。
>

##### 重力缩放系数 `gravityScale`

![img](img/2-2.png) 

（图2-2）

自然界中物体受地心吸引的作用而受到的力叫重力，物理引擎中也同样模拟了重力，并可以设置参数对其改变。

刚体的gravityScale属性是重力缩放系数，通过调整数值可以改变重力大小，数值可以为正数或负数，也包括了正负小数。默认值为1，即正常重力，IDE中如上图2-2所示。如果数值为0则表示没有重力。大于1的数值表示正常重力的倍数，数值越大则重力越大。gravityScale属性数值为负数，则表示反方向重力，数值越小则反方向的重力越大。

##### 角速度 `angularVelocity`

![img](img/2-3.png) 

（图2-3）

刚体的angularVelocity属性是角速度， 角速度简单理解就是单位时间的角位移，以弧度每秒进行旋转 。当我们设置angularVelocity属性为正值的时候，则按顺时针旋转位移。angularVelocity属性为负值的时候，则按逆时针旋转位移。属性值的绝对值越大，旋转位移速度越快。angulaVelocity属性的默认值为0，如图2-3所示，此时不会产生旋转位移。

##### 角阻尼 `angularDampin`

![img](img/2-4.png) 

（图2-4）

阻尼是外界作用或自身原因引起逐渐下降的衰减特性，刚体的角阻尼则是相对于角速度的旋转阻尼系数，使得旋转速度衰减。范围从0到无穷大。默认值为0，表示没有阻尼，如图2-4。通常阻尼的值应该在0到0.1之间。

##### 线性速度 `linearVelocity`

![img](img/2-5.png) 

（图2-5）

刚体的linearVelocity属性称为线速度或者线性速度，是物体任意一点对定轴作曲线或圆周运动时的速度。在理解角速度与线速度的关系上，假如我们围绕一个原点画一条曲线，那这个曲线从起始到结束的角度除以单位时间就是角速度，这个曲线的长度除以单位时间，就是线速度。

线速度是一个矢量值，既有大小也有方向 ，由于它的方向是沿运动轨道的切线方向，所以又称切向速度， 它是描述作曲线运动的质点运动快慢和方向的物理量。 在LayaAirIDE里，linearVelocity属性值，为xy坐标方向的速度值，例如图2-5中示例的`10,10`，表示x坐标（向右）速度为10，y坐标（向下）速度为10。坐标值可以为负值，坐标值的绝对值越大，速度越快。

##### 线性阻尼 `linearDamping`

![img](img/2-6.png) 

（图2-6）

刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。范围从0到无穷大。默认值为0，表示没有阻尼，如图2-6。通常阻尼的值应该在0到0.1之间。

##### 子弹 `bullet`

![IMG](img/2-7.png) 

（图2-7）

在有些情况下，物理引擎可能会捕捉不到某些已经发生的碰撞，导致互相穿透卡在一起。

刚体的bullet属性，中文是子弹，形容射出的子弹那样高速移动的物体，bullet属性用于防止高速穿透。

bullet默认值为false，如图2-7，此时不对刚体作防穿透处理（连续碰撞检测），会节省性能。当设置为true时，会通过连续碰撞检测防止高速穿透。

##### 允许休眠 `allowSleep`

![img](img/2-8.png) 

（图2-8）

物理引擎进行模拟时，是存在性能消耗的。当刚体停止运动时，其实我们可以不去模拟它。刚体设置为休眠状态就会跳过该刚体的模拟，直到被其它刚体解除才会醒来（关节被破坏或者手动唤醒也可以），从而节省性能的消耗。

刚体的allowSleep属性，中文是允许休眠，默认值为ture，如图2-8所示。如果想保持一直醒着的状态，设置为false可以关闭允许休眠。

##### 允许旋转 `allowRotation`

![img](img/2-9.png) 

（图2-9）

刚体的allowRotation属性，中文是允许旋转。这里可以控制刚体碰撞时角度是否发生旋转改变。默认值为true，如图2-9所示。表示允许刚体发生碰撞时模拟自然撞击的角度改变，看起来更加自然。当设置为false，碰撞后不会产生角度变化。

比如，一把受重力自由下落的尖刀，是希望碰到地板后，最终平躺在地板上。还是始终保持尖刀竖立的状态，可以通过allowRotation属性来控制。

##### 碰撞组 `group` 

![img](img/2-10.png) 

（图2-10）

group属性可以设置当前刚体所属的碰撞组。默认值为0，如图2-10。

碰撞组规则如下：

1、如果两个对象的刚体group相等且group值大于零，它们将始终会发生碰撞。

2、如果两个对象的刚体group相等且group值小于零，它们将永远不会发生碰撞。

3、如果两个对象的刚体group值等于0或者group值不相等，则使用刚体的碰撞类别category和碰撞掩码mask来判断是否碰撞。

##### 碰撞类别  `category`

![img](img/2-11.png) 

（图2-11）

category属性表示碰撞类别，与碰撞组group关联使用，默认值为1（2的0次方），如图2-11所示。

当两个对象的碰撞组（group）值等于0或者值不相等时，使用2的幂次方值来指定碰撞类别。此属性接收位字段，范围为[1,2^31]内2的幂，共有32种不同的碰撞类别可用。

> 按2的幂设置值不是强制规定，不会引发报错。但不按这个规则取值，就需要每次按位运算设置mask值，否则按category求和法来设置可能会导致结果出错，增加理解和设置mask值的成本。

##### 碰撞掩码 `mask`

![img](img/2-12.png) 

（图2-12）

mask属性表示碰撞掩码，默认值为-1，如图2-12所示。

碰撞掩码mask要与碰撞类别category互相关联来使用，用以实现碰撞过滤。比如游戏的战场之中有两大阵营联盟，每个阵营内部的不同军团之间不需要碰撞，不同阵营的军团需要碰撞。此时，就可以用碰撞掩码来指定要碰谁，不碰谁。

mask值是所有碰撞类别category按位AND的值，这块理解起来需要用到对位运算的知识，我们也可以用碰撞类别category值求和来简单快速理解一下。

假如，ABCD四个刚体，碰撞类别category分别为1、2、8、4。那刚体E要与ABC发生碰撞，则E的mask应设置为11。要与ABCD都发生碰撞，则mask应设置为15。要与ACD发生碰撞，则mask应设置为7。

0x0000 = 0

0x0001 = 1

0x0002 = 2

0x0004 = 4

0x0008 = 8

 

0x0010 = 16

0x0020 = 32

0x0040 = 64

0x0080 = 128

 

0x0100 = 256

0x0200 = 512

0x0400 = 1024

0x0800 = 2048

 

0x1000 = 4096

0x2000 = 8192

0x4000 = 16384

0x8000 = 32768

##### 刚体标签 `label` 

![img](img/2-13.png) 

（图2-13）

label属性是刚体的标签名，默认值是RigidBody。如图2-13。

当我们想在项目代码中，通过自定义标签名来识别该刚体，用于判断控制的时候，可以在label属性中进行设置。

#### 2.2  碰撞体 `collider` 

LayaAir引擎与IDE基于Box2D物理引擎的形状（shape）封装了更容易理解和使用的碰撞体（collider）。下面针对LayaAir碰撞体进行介绍。

##### 2.2.1 碰撞体与刚体的关系

碰撞体顾名思义，是用来检测碰撞的组件，而刚体是使游戏物体能获得重力和接受力的组件。没有碰撞体，只有刚体，则无法产生碰撞效果。

在LayaAirIDE中，使用碰撞体组件，但没有添加刚体时，会强行添加刚体组件。碰撞体是必须依附于刚体的2D碰撞几何结构。具有摩擦(friction)和恢复(restitution)的材料性质。

##### 2.2.2 碰撞体的种类

![img](img/3.png) 

(图3)

碰撞体一共有四种，如图3。我们根据2D几何图形的外观特性，分别命名为：矩形碰撞体`BoxCollider`，圆形碰撞体`CircleCollider`，线形碰撞体`ChainCollider`，多边形碰撞体`PolygonCollider`。

> boxCollider也可以称为盒子碰撞体，chainCollider也可以称为链碰撞体。

##### 2.2.3 碰撞体的基类属性

四种碰撞体都继承于碰撞体基类ColliderBase，有着共有的基类属性。我们先介绍一下通用的属性和基类的属性。稍后再分别介绍各碰撞体的特有属性。

##### 坐标 `x`、`y`

![img](img/4-1.png) 

（图4-1）

碰撞体的坐标与父子节点坐标作用一样。x和y属性是与该碰撞体所属节点偏移的坐标，默认值都为0，如图4-1所示，修改碰撞体x与y的坐标位置就是修改与其节点偏移的位置。

##### 摩擦力 `friction`

![img](img/4-2.png) 

（图4-2）

当两个相互接触并挤压的物体发生相对运动或具有相对运动趋势时，就会在接触面上产生阻碍相对运动或相对运动趋势的力，这种力叫做摩擦力。 

碰撞体上的摩擦力可以使对象逼真地沿其它对象滑动，摩擦力friction的属性值设置范围是0到1，值越大表示摩擦力越大， 0表示没有摩擦，1表示强摩擦， 几乎移不动的摩擦。 默认值为0.2，如图4-2所示。 

##### 恢复 `restitution`

![img](img/4-3.png) 

（图4-3）

碰撞体的restitution属性直译是恢复，恢复可以使对象弹起，我们可以想象一下打乒乓球、篮球等，以恢复的特性使其弹出或弹起。所以恢复表示一种弹性的碰撞现象。

对于restitution属性值，我们可以理解为弹性系数。值的设置范围是0到1，值越大表示弹性越大。如图4-3的默认值为0，此时不具有弹性，1的时候为完全弹性碰撞，会以同样的速度反弹。 

##### 密度 `density`

![img](img/4-4.png) 

（图4-4）

密度是单位体积的质量。当一个对象的密度越大，那么它的质量就越大，碰撞时也就相对更难以移动。

密度density值可以为零或者是正数，如果为零， 那将会是一个静止的对象。 IDE里的默认值为10，如图4-4所示。建议使用相似的密度，当产生多物体堆叠在一起时，这样做可以使得堆叠更加稳定。

##### 是否为传感器 `isSensor`

![img](img/4-5.png) 

（图4-5）

当游戏逻辑需要判断两个碰撞体是否相交，但不需要有碰撞反应。这时候，可以通过传感器来完成。传感器会侦测碰撞而不产生碰撞反应。

isSensor的默认值为false，如图4-5所示，表示不是传感器。当设置为true时，表示为传感器，此时能够触发碰撞事件，但不会产生碰撞反应。

##### 碰撞体标签 `label`

![img](img/4-6.png) 

（图4-6）

碰撞体标签与刚体标签一样，当自定义了标签名后，用于项目代码中识别控制。

label属性的默认值是当前碰撞体的种类名，在LayaAirIDE 创建的2D示例项目中，地板的矩形碰撞体BoxCollider，就使用了自定义的标签ground，如图4-6所示。

##### 2.2.4 矩形碰撞体 `BoxCollider`

![img](img/5-1.png) 

（图5-1）

##### 宽高 `width、height`

矩形碰撞体BoxCollider，是封闭的直角平行四边形碰撞框，为节点添加BoxCollider组件后，默认的BoxCollider宽高会等于该节点的宽高。如果节点的宽高改变后，可以手动更改BoxCollider的width和height改变。或者通过fitsize功能来适配节点的宽高。

##### 适配宽高大小 `fitsize`

![img](img/5-2.png) 

（图5-2）

当BoxCollider碰撞体的所属节点宽高改变后，碰撞体大小不会自动跟随改变。快捷的方法是，点击图5-2所示的fitsize按钮，可以自动按节点当前的宽高适配改变碰撞体的大小，让碰撞体的宽高等于所属节点的宽高。

##### 2.2.5 圆形碰撞体 CircleCollider

![img](img/6-1.png) 

（图6-1）

##### 半径 `radius`

圆形碰撞体CircleCollider，是一个封闭的圆形框，其大小是通过半径来控制，半径越大，碰撞体的圆形框越大。

当节点添加CircleCollider组件后，半径值默认为该节点的width的一半。如果节点宽高被改变，需要手动修改半径radius值，或者通过fitsize快捷的设置为该节点width的一半。

##### 适配半径大小`fitsize`

![img](img/6-2.png) 

（图6-2）

CircleCollider的fitsize与BoxCollider的fitsize作用其实一样，都是自动按节点来适配碰撞体大小，只不过规则不同而已。在4种不同的碰撞体种类里，只有BoxCollider与CircleCollider支持fitsize这种自动适配碰撞体大小的功能。

##### 2.2.6 线形碰撞体 `ChainCollider` 、多边形碰撞体 `PolygonCollider`

ChainCollider与PolygonCollider这两种碰撞体，除了继承的基类属性外，还有一个通用的属性Points。它们都是用xy坐标点来表示一个线段节点，两个线段节点之间为线段或边，两种碰撞体都可以直接增加线段节点，让ChainCollider成为链条状碰撞体，让PolygonCollider成为任意多边形框状碰撞体。

需要注意的是，这两种碰撞体的线段或者边，都不能进行穿插重叠，否则在使用时就会出现问题，下图7-1就是ChainCollider与PolygonCollider的错误示例。

![img](img/7-1.png) 

（图7-1）

正确的做法是，ChainCollider碰撞体为不封闭的形状或线段，PolygonCollider为一个整体的凸多边形。如下图7-2所示。

![img](img/7-2.png) 

（图7-2）

共同的特点，都是由两个点组成一个线段，并可延伸无限个线段，所以他们有通用的属性Points。区别是ChainCollider首尾两端不是封闭的，PolygonCollider一定是封闭的多边形框。

##### 点坐标集合 `Points`

![img](img/7-3.png)  

（图7-3）

Points的属性是一个由xy坐标组成的点集合，每个x和y坐标为一个线段节点，每一个坐标都是以逗号间隔区分。线段节点的个数不能少于2个，多边形的线段节点个数不能少于3个。

除了直接在属性栏里输入坐标数值，如图7-3所示。在编辑界面中可以更快捷的操作。直接拖动线段节点改变位置，直接点击线段增加新的线段节点。双击线段节点可以删除该节点。

#### 2.3 关节 `Joint`

 关节用于将刚体约束到物理世界或彼此约束。 譬如游戏中的提线木偶、钟摆等都是关节的应用。

LayaAir引擎封装了10种关节组件，可在IDE中直接添加使用，如图8所示。分别为：距离关节`DistanceJoint`、齿轮关节 `GearJoint`、马达关节`MotorJoint`、鼠标关节`MouseJoint`、平移关节`PrismaticJoint`、滑轮关节`PulleyJoint`、旋转关节`RevoluteJoint`、绳索关节`RopeJoint`、焊接关节`WeldJoint`、轮子关节`WheelJoint`。

![img](img/8.png) 

（图8）

##### 2.3.1 距离关节`DistanceJoint`

距离关节描述了两个刚体锚点之间的距离，并且保持着这个约束的距离。 默认状态下像弹簧一样连接着两个刚体点，也可以像铁棍一样始终固定连接两点。

![img](img/9-1.png) 

（图9-1）

##### 另一个刚体 `otherBody`

距离关节必须由两个刚体组成，otherBody属性用于绑定另一个刚体，此处需要拖拽层级面板中的目标节点或者目标节点刚体到该属性栏目。拖拽后，如图9-1所示。双击已绑定的otherBody属性输入栏，被绑定的目标刚体会在层级面板中自动展开并连续闪烁，方便我们快速定位被绑定的是哪个刚体。

至于两个刚体之间，谁是绑定或被绑定（otherBody）的关系，要综合实际业务逻辑考虑。仅是为了体现两者的约束关系，那谁是绑定者，并没有什么区别。

##### 另一个锚点 `otherAnchor`、自身锚点 `selfAnchor` 

每一个刚体都有一个刚体锚点，默认是在刚体的左上角（自身`(0,0)`坐标），使用距离关节后，当选中距离关节，场景编辑面板中会出现一红一绿两个圆点，绿色圆点为自身锚点selfAnchor，红色锚点为otherBody绑定的另一个刚体锚点。如果没有进行绑定，则是默认绑定到场景的初始坐标`(0,0)`。效果如下图9-2所示。

![img](img/9-2.png) 

（图9-2）

通常我们会指定锚点位置，例如钟摆的示例，如下图9-3所示。

![img](img/9-3.png) 

（图9-3）

##### 振动频率 `frequency`、`damping`



















































## 本文赞赏

如果您觉得本文对您有帮助，欢迎扫码赞赏作者，您的激励是我们写出更多优质文档的动力。

![pay](../../../../wechatPay.jpg)